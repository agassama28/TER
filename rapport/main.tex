\documentclass[a4paper,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{amsthm}
\usepackage{comment}
\usepackage{float}
\geometry{margin=2.5cm}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}

\theoremstyle{definition}
\newtheorem{dfn}{Definition}

\theoremstyle{plain}
\newtheorem{prop}{Proposition}

\newtheorem{lem}{Lemme}

\newcommand{\E}{\mathbb{E}}
\newcommand{\Prb}{\mathbb{P}}
\newcommand{\Var}{\operatorname{Var}}
\newcommand{\sumin}{\sum_{i=1}^n}
\newcommand{\limN}{\xrightarrow[n \to \infty]{}}

\title{Random Graphs}
\author{Abdoulaye GASSAMA \\ Sen ZHOU}
\date{\today}

\begin{document}

\maketitle

\tableofcontents

\begin{abstract}

\end{abstract}

\begin{dfn}
A graph \(G = (V,E)\) is a collection of elements called vertices connected by edges. The set of vertices is denoted by \(V\) (from “vertices”), and the set of edges is denoted by \(E\) (from “edges”), where \(E \subset V \times V\). We denoted the set of graphs \(\mathcal{G}\).
\end{dfn}

\begin{dfn}
Let \(n \in \mathbb{N} \) and \(p \in [0,1]\). A random graph \( G \in \mathcal{G}(n,p)\) is defined as \( G = (V,E)\) where:
\(V = \{1,...,n\}\).\( \{i,j \} \in \binom{V}{2}\), \(\Prb(\{i,j\} \in E)=p\).
\end{dfn}

\section{Simulation of Graph \(\mathcal{G}(n,p)\)}
In this section the objective is to simulate a random graph carried out by Python.For this we will need of the library networkx which give access to some useful functions.
\begin{enumerate}
\item Initialisation of parameters
\begin{verbatim}
n = 10 # number of vertices
p = 0.5
nb_graph = 10**4
graph_list = []
\end{verbatim}

\item Function which generates an oriented random graph (i < j)
\begin{verbatim}
def generate_oriented_graph(n, p):
    G = nx.DiGraph()
    G.add_nodes_from(range(1, n+1)) 

    for i in range(1, n+1):
        for j in range(i+1, n+1):  # i < j
            if np.random.rand() < p:
                G.add_edge(i, j)
    
    return G
\end{verbatim}    

\newpage

\item Loop which generates a list of graph
\begin{verbatim}
for i in range(nb_graph):
    G = generate_oriented_graph(n, p)
    graph_list.append(G)
\end{verbatim}

\item Computation of \( \frac{\#\{\text{graphs where } 1 \to n\}}{\#\{\text{simulations}\}}\)
\begin{verbatim}    
graph_1_n = 0
for i in range(nb_graph):
    if (nx.has_path(graph_list[i], 1, n)):
        graph_1_n += 1 
\end{verbatim}
\end{enumerate}        
\end{document}